#version 460

layout (local_size_x = 32, local_size_y = 32) in;
layout (binding = 0, rgba8) uniform writeonly image2D output_image;


uint model_level = 3;


vec3 poses[8] = {
	vec3(0, 0, 0) - 0.5,
	vec3(1, 0, 0) - 0.5,
	vec3(0, 1, 0) - 0.5,
	vec3(1, 1, 0) - 0.5,
	vec3(0, 0, 1) - 0.5,
	vec3(1, 0, 1) - 0.5,
	vec3(0, 1, 1) - 0.5,
	vec3(1, 1, 1) - 0.5
};


vec4 materials[] = {
	vec4(1)
};


int model_data[] = {
	0x7,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
};



bool ray_box(vec3 ro, vec3 rd, float size, out float t) {
	float idx = 1. / rd.x;
	float idy = 1. / rd.y;
	float idz = 1. / rd.z;

	float t1 = (-size - ro.x) * idx;
	float t2 = ( size - ro.x) * idx;
	float t3 = (-size - ro.y) * idy;
	float t4 = ( size - ro.y) * idy;
	float t5 = (-size - ro.z) * idz;
	float t6 = ( size - ro.z) * idz;

	float tmin = max(max(min(t1,t2), min(t3,t4)), min(t5,t6));
	float tmax = min(min(max(t1,t2), max(t3,t4)), max(t5,t6));

	t = tmin;

	return tmax >= 0 && tmin < tmax;
}


bool is_point_in_box(vec3 p, float size) {
	//size *= 0.5;
	return abs(p.x) <= size && abs(p.y) <= size && abs(p.z) <= size;
}


int id_from_poin(vec3 p) {
	ivec3 sp = ivec3(sign(p) * 0.5 + 0.5);
	return sp.x + sp.y * 2 + sp.z * 4;
}


uint stack_id[512];
vec3 stack_pos[512];
uint stack_level[512];
int stack_head = 0;


void stack_push(uint id, uint level, vec3 pos) {
	stack_id[stack_head] = id;
	stack_level[stack_head] = level;
	stack_pos[stack_head] = pos;
	stack_head++;
}

void stack_pop(out uint id, out uint level, out vec3 pos) {
	stack_head--;
	id = stack_id[stack_head];
	level = stack_level[stack_head];
	pos = stack_pos[stack_head];
}


bool march(vec3 ro, vec3 rd, out float out_t) {
	stack_push(0, model_level, vec3(0));

	vec3 result = vec3(0);

	while (stack_head != 0) {
		uint id;
		uint level;
		vec3 pos;
		stack_pop(id, level, pos);

		float t;
		float size = pow(2, level);

		if (!ray_box(ro - pos, rd, size, t))
			continue;

		if (level == 0) {
			result = vec3(1);
			out_t = t;
			return true;
		}

		uint data = model_data[id];

		uint offset = 1;

		for (int i = 0; i < 8; i++) {
			if (((data >> i) & 1) == 0)
				continue;

			uint new_id = model_data[id + offset];
			offset++;

			stack_push(new_id, level - 1, pos + poses[i] * size);
		}
	}

	return false;
}


mat2 rot(float a) {
	return mat2(
		cos(a), -sin(a),
		sin(a),  cos(a)
	);
}


void main() {
	vec2 image_size = imageSize(output_image);
	vec2 uv = ivec2(gl_GlobalInvocationID.xy) / image_size * 2 - 1;
	uv.x *= image_size.x / image_size.y;

	vec3 ro = vec3(0,0,0) - vec3(0,0,16);
	vec3 rd = normalize(vec3(uv, 1));

	//rd.yz *= rot(-0.5);
	//rd.xz *= rot(0.5);

	float t;
	bool hit = march(ro, rd, t);
	vec3 color = vec3(0);

	if (hit) {
		color = vec3(t) / 20;
	}

	imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), vec4(color,1));
}
